# coding: utf-8

"""
    Consumer Data Standards

    API sets created by the Australian Consumer Data Standards to meet the needs of the Consumer Data Right  # noqa: E501

    OpenAPI spec version: 1.1.1
    Contact: cdr-data61@csiro.au
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class BankingScheduledPaymentRecurrenceLastWeekday(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'final_payment_date': 'str',
        'payments_remaining': 'int',
        'interval': 'str',
        'last_week_day': 'str',
        'non_business_day_treatment': 'str'
    }

    attribute_map = {
        'final_payment_date': 'finalPaymentDate',
        'payments_remaining': 'paymentsRemaining',
        'interval': 'interval',
        'last_week_day': 'lastWeekDay',
        'non_business_day_treatment': 'nonBusinessDayTreatment'
    }

    def __init__(self, final_payment_date=None, payments_remaining=None, interval=None, last_week_day=None, non_business_day_treatment='ON'):  # noqa: E501
        """BankingScheduledPaymentRecurrenceLastWeekday - a model defined in Swagger"""  # noqa: E501

        self._final_payment_date = None
        self._payments_remaining = None
        self._interval = None
        self._last_week_day = None
        self._non_business_day_treatment = None
        self.discriminator = None

        if final_payment_date is not None:
            self.final_payment_date = final_payment_date
        if payments_remaining is not None:
            self.payments_remaining = payments_remaining
        self.interval = interval
        self.last_week_day = last_week_day
        if non_business_day_treatment is not None:
            self.non_business_day_treatment = non_business_day_treatment

    @property
    def final_payment_date(self):
        """Gets the final_payment_date of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501

        The limit date after which no more payments should be made using this schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely  # noqa: E501

        :return: The final_payment_date of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :rtype: str
        """
        return self._final_payment_date

    @final_payment_date.setter
    def final_payment_date(self, final_payment_date):
        """Sets the final_payment_date of this BankingScheduledPaymentRecurrenceLastWeekday.

        The limit date after which no more payments should be made using this schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely  # noqa: E501

        :param final_payment_date: The final_payment_date of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :type: str
        """

        self._final_payment_date = final_payment_date

    @property
    def payments_remaining(self):
        """Gets the payments_remaining of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501

        Indicates the number of payments remaining in the schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely  # noqa: E501

        :return: The payments_remaining of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :rtype: int
        """
        return self._payments_remaining

    @payments_remaining.setter
    def payments_remaining(self, payments_remaining):
        """Sets the payments_remaining of this BankingScheduledPaymentRecurrenceLastWeekday.

        Indicates the number of payments remaining in the schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely  # noqa: E501

        :param payments_remaining: The payments_remaining of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :type: int
        """

        self._payments_remaining = payments_remaining

    @property
    def interval(self):
        """Gets the interval of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501

        The interval for the payment. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax) with components less than a day in length ignored. This duration defines the period between payments starting with nextPaymentDate  # noqa: E501

        :return: The interval of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :rtype: str
        """
        return self._interval

    @interval.setter
    def interval(self, interval):
        """Sets the interval of this BankingScheduledPaymentRecurrenceLastWeekday.

        The interval for the payment. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax) with components less than a day in length ignored. This duration defines the period between payments starting with nextPaymentDate  # noqa: E501

        :param interval: The interval of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :type: str
        """
        if interval is None:
            raise ValueError("Invalid value for `interval`, must not be `None`")  # noqa: E501

        self._interval = interval

    @property
    def last_week_day(self):
        """Gets the last_week_day of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501

        The weekDay specified. The payment will occur on the last occurrence of this weekday in the interval.  # noqa: E501

        :return: The last_week_day of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :rtype: str
        """
        return self._last_week_day

    @last_week_day.setter
    def last_week_day(self, last_week_day):
        """Sets the last_week_day of this BankingScheduledPaymentRecurrenceLastWeekday.

        The weekDay specified. The payment will occur on the last occurrence of this weekday in the interval.  # noqa: E501

        :param last_week_day: The last_week_day of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :type: str
        """
        if last_week_day is None:
            raise ValueError("Invalid value for `last_week_day`, must not be `None`")  # noqa: E501
        allowed_values = ["MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"]  # noqa: E501
        if last_week_day not in allowed_values:
            raise ValueError(
                "Invalid value for `last_week_day` ({0}), must be one of {1}"  # noqa: E501
                .format(last_week_day, allowed_values)
            )

        self._last_week_day = last_week_day

    @property
    def non_business_day_treatment(self):
        """Gets the non_business_day_treatment of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501

        Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored  # noqa: E501

        :return: The non_business_day_treatment of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :rtype: str
        """
        return self._non_business_day_treatment

    @non_business_day_treatment.setter
    def non_business_day_treatment(self, non_business_day_treatment):
        """Sets the non_business_day_treatment of this BankingScheduledPaymentRecurrenceLastWeekday.

        Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored  # noqa: E501

        :param non_business_day_treatment: The non_business_day_treatment of this BankingScheduledPaymentRecurrenceLastWeekday.  # noqa: E501
        :type: str
        """
        allowed_values = ["AFTER", "BEFORE", "ON", "ONLY"]  # noqa: E501
        if non_business_day_treatment not in allowed_values:
            raise ValueError(
                "Invalid value for `non_business_day_treatment` ({0}), must be one of {1}"  # noqa: E501
                .format(non_business_day_treatment, allowed_values)
            )

        self._non_business_day_treatment = non_business_day_treatment

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(BankingScheduledPaymentRecurrenceLastWeekday, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, BankingScheduledPaymentRecurrenceLastWeekday):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
