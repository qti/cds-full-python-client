# coding: utf-8

"""
    Consumer Data Standards

    API sets created by the Australian Consumer Data Standards to meet the needs of the Consumer Data Right  # noqa: E501

    OpenAPI spec version: 1.1.1
    Contact: cdr-data61@csiro.au
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class BankingScheduledPayment(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'scheduled_payment_id': 'str',
        'nickname': 'str',
        'payer_reference': 'str',
        'payee_reference': 'str',
        'status': 'str',
        '_from': 'BankingScheduledPaymentFrom',
        'payment_set': 'list[BankingScheduledPaymentSet]',
        'recurrence': 'BankingScheduledPaymentRecurrence'
    }

    attribute_map = {
        'scheduled_payment_id': 'scheduledPaymentId',
        'nickname': 'nickname',
        'payer_reference': 'payerReference',
        'payee_reference': 'payeeReference',
        'status': 'status',
        '_from': 'from',
        'payment_set': 'paymentSet',
        'recurrence': 'recurrence'
    }

    def __init__(self, scheduled_payment_id=None, nickname=None, payer_reference=None, payee_reference=None, status=None, _from=None, payment_set=None, recurrence=None):  # noqa: E501
        """BankingScheduledPayment - a model defined in Swagger"""  # noqa: E501

        self._scheduled_payment_id = None
        self._nickname = None
        self._payer_reference = None
        self._payee_reference = None
        self._status = None
        self.__from = None
        self._payment_set = None
        self._recurrence = None
        self.discriminator = None

        self.scheduled_payment_id = scheduled_payment_id
        if nickname is not None:
            self.nickname = nickname
        self.payer_reference = payer_reference
        self.payee_reference = payee_reference
        self.status = status
        self._from = _from
        self.payment_set = payment_set
        self.recurrence = recurrence

    @property
    def scheduled_payment_id(self):
        """Gets the scheduled_payment_id of this BankingScheduledPayment.  # noqa: E501

        A unique ID of the scheduled payment adhering to the standards for ID permanence  # noqa: E501

        :return: The scheduled_payment_id of this BankingScheduledPayment.  # noqa: E501
        :rtype: str
        """
        return self._scheduled_payment_id

    @scheduled_payment_id.setter
    def scheduled_payment_id(self, scheduled_payment_id):
        """Sets the scheduled_payment_id of this BankingScheduledPayment.

        A unique ID of the scheduled payment adhering to the standards for ID permanence  # noqa: E501

        :param scheduled_payment_id: The scheduled_payment_id of this BankingScheduledPayment.  # noqa: E501
        :type: str
        """
        if scheduled_payment_id is None:
            raise ValueError("Invalid value for `scheduled_payment_id`, must not be `None`")  # noqa: E501

        self._scheduled_payment_id = scheduled_payment_id

    @property
    def nickname(self):
        """Gets the nickname of this BankingScheduledPayment.  # noqa: E501

        The short display name of the payee as provided by the customer  # noqa: E501

        :return: The nickname of this BankingScheduledPayment.  # noqa: E501
        :rtype: str
        """
        return self._nickname

    @nickname.setter
    def nickname(self, nickname):
        """Sets the nickname of this BankingScheduledPayment.

        The short display name of the payee as provided by the customer  # noqa: E501

        :param nickname: The nickname of this BankingScheduledPayment.  # noqa: E501
        :type: str
        """

        self._nickname = nickname

    @property
    def payer_reference(self):
        """Gets the payer_reference of this BankingScheduledPayment.  # noqa: E501

        The reference for the transaction that will be used by the originating institution for the purposes of constructing a statement narrative on the payer’s account. Empty string if no data provided  # noqa: E501

        :return: The payer_reference of this BankingScheduledPayment.  # noqa: E501
        :rtype: str
        """
        return self._payer_reference

    @payer_reference.setter
    def payer_reference(self, payer_reference):
        """Sets the payer_reference of this BankingScheduledPayment.

        The reference for the transaction that will be used by the originating institution for the purposes of constructing a statement narrative on the payer’s account. Empty string if no data provided  # noqa: E501

        :param payer_reference: The payer_reference of this BankingScheduledPayment.  # noqa: E501
        :type: str
        """
        if payer_reference is None:
            raise ValueError("Invalid value for `payer_reference`, must not be `None`")  # noqa: E501

        self._payer_reference = payer_reference

    @property
    def payee_reference(self):
        """Gets the payee_reference of this BankingScheduledPayment.  # noqa: E501

        The reference for the transaction that will be provided by the originating institution. Empty string if no data provided  # noqa: E501

        :return: The payee_reference of this BankingScheduledPayment.  # noqa: E501
        :rtype: str
        """
        return self._payee_reference

    @payee_reference.setter
    def payee_reference(self, payee_reference):
        """Sets the payee_reference of this BankingScheduledPayment.

        The reference for the transaction that will be provided by the originating institution. Empty string if no data provided  # noqa: E501

        :param payee_reference: The payee_reference of this BankingScheduledPayment.  # noqa: E501
        :type: str
        """
        if payee_reference is None:
            raise ValueError("Invalid value for `payee_reference`, must not be `None`")  # noqa: E501

        self._payee_reference = payee_reference

    @property
    def status(self):
        """Gets the status of this BankingScheduledPayment.  # noqa: E501

        Indicates whether the schedule is currently active. The value SKIP is equivalent to ACTIVE except that the customer has requested the next normal occurrence to be skipped.  # noqa: E501

        :return: The status of this BankingScheduledPayment.  # noqa: E501
        :rtype: str
        """
        return self._status

    @status.setter
    def status(self, status):
        """Sets the status of this BankingScheduledPayment.

        Indicates whether the schedule is currently active. The value SKIP is equivalent to ACTIVE except that the customer has requested the next normal occurrence to be skipped.  # noqa: E501

        :param status: The status of this BankingScheduledPayment.  # noqa: E501
        :type: str
        """
        if status is None:
            raise ValueError("Invalid value for `status`, must not be `None`")  # noqa: E501
        allowed_values = ["ACTIVE", "SKIP", "INACTIVE"]  # noqa: E501
        if status not in allowed_values:
            raise ValueError(
                "Invalid value for `status` ({0}), must be one of {1}"  # noqa: E501
                .format(status, allowed_values)
            )

        self._status = status

    @property
    def _from(self):
        """Gets the _from of this BankingScheduledPayment.  # noqa: E501


        :return: The _from of this BankingScheduledPayment.  # noqa: E501
        :rtype: BankingScheduledPaymentFrom
        """
        return self.__from

    @_from.setter
    def _from(self, _from):
        """Sets the _from of this BankingScheduledPayment.


        :param _from: The _from of this BankingScheduledPayment.  # noqa: E501
        :type: BankingScheduledPaymentFrom
        """
        if _from is None:
            raise ValueError("Invalid value for `_from`, must not be `None`")  # noqa: E501

        self.__from = _from

    @property
    def payment_set(self):
        """Gets the payment_set of this BankingScheduledPayment.  # noqa: E501


        :return: The payment_set of this BankingScheduledPayment.  # noqa: E501
        :rtype: list[BankingScheduledPaymentSet]
        """
        return self._payment_set

    @payment_set.setter
    def payment_set(self, payment_set):
        """Sets the payment_set of this BankingScheduledPayment.


        :param payment_set: The payment_set of this BankingScheduledPayment.  # noqa: E501
        :type: list[BankingScheduledPaymentSet]
        """
        if payment_set is None:
            raise ValueError("Invalid value for `payment_set`, must not be `None`")  # noqa: E501

        self._payment_set = payment_set

    @property
    def recurrence(self):
        """Gets the recurrence of this BankingScheduledPayment.  # noqa: E501


        :return: The recurrence of this BankingScheduledPayment.  # noqa: E501
        :rtype: BankingScheduledPaymentRecurrence
        """
        return self._recurrence

    @recurrence.setter
    def recurrence(self, recurrence):
        """Sets the recurrence of this BankingScheduledPayment.


        :param recurrence: The recurrence of this BankingScheduledPayment.  # noqa: E501
        :type: BankingScheduledPaymentRecurrence
        """
        if recurrence is None:
            raise ValueError("Invalid value for `recurrence`, must not be `None`")  # noqa: E501

        self._recurrence = recurrence

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(BankingScheduledPayment, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, BankingScheduledPayment):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
