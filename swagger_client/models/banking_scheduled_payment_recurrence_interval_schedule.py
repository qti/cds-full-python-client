# coding: utf-8

"""
    Consumer Data Standards

    API sets created by the Australian Consumer Data Standards to meet the needs of the Consumer Data Right  # noqa: E501

    OpenAPI spec version: 1.1.1
    Contact: cdr-data61@csiro.au
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class BankingScheduledPaymentRecurrenceIntervalSchedule(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'final_payment_date': 'str',
        'payments_remaining': 'int',
        'non_business_day_treatment': 'str',
        'intervals': 'list[BankingScheduledPaymentInterval]'
    }

    attribute_map = {
        'final_payment_date': 'finalPaymentDate',
        'payments_remaining': 'paymentsRemaining',
        'non_business_day_treatment': 'nonBusinessDayTreatment',
        'intervals': 'intervals'
    }

    def __init__(self, final_payment_date=None, payments_remaining=None, non_business_day_treatment='ON', intervals=None):  # noqa: E501
        """BankingScheduledPaymentRecurrenceIntervalSchedule - a model defined in Swagger"""  # noqa: E501

        self._final_payment_date = None
        self._payments_remaining = None
        self._non_business_day_treatment = None
        self._intervals = None
        self.discriminator = None

        if final_payment_date is not None:
            self.final_payment_date = final_payment_date
        if payments_remaining is not None:
            self.payments_remaining = payments_remaining
        if non_business_day_treatment is not None:
            self.non_business_day_treatment = non_business_day_treatment
        self.intervals = intervals

    @property
    def final_payment_date(self):
        """Gets the final_payment_date of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501

        The limit date after which no more payments should be made using this schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely  # noqa: E501

        :return: The final_payment_date of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501
        :rtype: str
        """
        return self._final_payment_date

    @final_payment_date.setter
    def final_payment_date(self, final_payment_date):
        """Sets the final_payment_date of this BankingScheduledPaymentRecurrenceIntervalSchedule.

        The limit date after which no more payments should be made using this schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely  # noqa: E501

        :param final_payment_date: The final_payment_date of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501
        :type: str
        """

        self._final_payment_date = final_payment_date

    @property
    def payments_remaining(self):
        """Gets the payments_remaining of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501

        Indicates the number of payments remaining in the schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value, If neither field is present the payments will continue indefinitely  # noqa: E501

        :return: The payments_remaining of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501
        :rtype: int
        """
        return self._payments_remaining

    @payments_remaining.setter
    def payments_remaining(self, payments_remaining):
        """Sets the payments_remaining of this BankingScheduledPaymentRecurrenceIntervalSchedule.

        Indicates the number of payments remaining in the schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value, If neither field is present the payments will continue indefinitely  # noqa: E501

        :param payments_remaining: The payments_remaining of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501
        :type: int
        """

        self._payments_remaining = payments_remaining

    @property
    def non_business_day_treatment(self):
        """Gets the non_business_day_treatment of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501

        Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored  # noqa: E501

        :return: The non_business_day_treatment of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501
        :rtype: str
        """
        return self._non_business_day_treatment

    @non_business_day_treatment.setter
    def non_business_day_treatment(self, non_business_day_treatment):
        """Sets the non_business_day_treatment of this BankingScheduledPaymentRecurrenceIntervalSchedule.

        Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored  # noqa: E501

        :param non_business_day_treatment: The non_business_day_treatment of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501
        :type: str
        """
        allowed_values = ["AFTER", "BEFORE", "ON", "ONLY"]  # noqa: E501
        if non_business_day_treatment not in allowed_values:
            raise ValueError(
                "Invalid value for `non_business_day_treatment` ({0}), must be one of {1}"  # noqa: E501
                .format(non_business_day_treatment, allowed_values)
            )

        self._non_business_day_treatment = non_business_day_treatment

    @property
    def intervals(self):
        """Gets the intervals of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501

        An array of interval objects defining the payment schedule.  Each entry in the array is additive, in that it adds payments to the overall payment schedule.  If multiple intervals result in a payment on the same day then only one payment will be made. Must have at least one entry  # noqa: E501

        :return: The intervals of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501
        :rtype: list[BankingScheduledPaymentInterval]
        """
        return self._intervals

    @intervals.setter
    def intervals(self, intervals):
        """Sets the intervals of this BankingScheduledPaymentRecurrenceIntervalSchedule.

        An array of interval objects defining the payment schedule.  Each entry in the array is additive, in that it adds payments to the overall payment schedule.  If multiple intervals result in a payment on the same day then only one payment will be made. Must have at least one entry  # noqa: E501

        :param intervals: The intervals of this BankingScheduledPaymentRecurrenceIntervalSchedule.  # noqa: E501
        :type: list[BankingScheduledPaymentInterval]
        """
        if intervals is None:
            raise ValueError("Invalid value for `intervals`, must not be `None`")  # noqa: E501

        self._intervals = intervals

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(BankingScheduledPaymentRecurrenceIntervalSchedule, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, BankingScheduledPaymentRecurrenceIntervalSchedule):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
